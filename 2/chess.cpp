// FIX ME задача не шаблону
/*
 * //Хромой король.На квадратной доске расставлены монеты, достоинством от 1 до
 * //100. Хромой король, находящийся в правом нижнем углу, мечтает попасть в левый верхний.
 * //При этом он может передвигаться только в клетку слева или сверху и хочет, чтобы сумма всех
 * //монет, оказавшихся у него на пути, была бы максимальной.Определить эту сумму и путь, каким
 * //образом должен двигаться король, чтобы ее собрать.Ввод и вывод организовать при помощи
 * //текстовых файлов.Формат входных данных : в первой строке входного файла записано число
 * //N - размер доски(1 < N < 80).Далее следует N строк, каждая из которых содержит N целых чисел,
 * //представляющих доску.В первую строку выходного файл нужно вывести единственное число :
 * //максимальную сумму, а во второй строке вывести путь в виде строки символов, обозначив
 * //символом L движение влево, а символом U - движение вверх.
*/

/*
 * Продолжение задачи №2
 * Хромой король.На квадратной доске расставлены монеты, достоинством от 1 до
 * 100. Хромой король, находящийся в правом нижнем углу, мечтает попасть в левый верхний.
 * При этом он может передвигаться только в клетку слева или сверху и хочет, чтобы сумма всех
 * монет, оказавшихся у него на пути, была бы максимальной.Определить эту сумму и путь, каким
 * образом должен двигаться король, чтобы ее собрать.Ввод и вывод организовать при помощи
 * текстовых файлов.Формат входных данных : в первой строке входного файла записано число
 * N - размер доски(1 < N < 80).Далее следует N строк, каждая из которых содержит N целых чисел,
 * представляющих доску.В первую строку выходного файл нужно вывести единственное число :
 * максимальную сумму, а во второй строке вывести путь в виде строки символов, обозначив
 * символом L движение влево, а символом U - движение вверх.
*/

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;
// FIXME: Глобальная переменная - нарушение стиля
// int n;
// Исправлено: передаем размер как параметр

/**
 * Решает задачу хромого короля
 * @param board Доска с монетами
 * @param dp Матрица для хранения максимальных сумм
 * @param path Матрица для хранения пути
 */

//Нарушение именования функции и параметров
//void Solve(vector<vector<int>>& a, vector<vector<int>>& b, vector<vector<char>>& put)
void SolveKingProblem(vector<vector<int>>& board,
    vector<vector<int>>& dp,
    vector<vector<char>>& path) 
    {
    int n = board.size();
    dp[n - 1][n - 1] = board[n - 1][n - 1];

    for (int i = n - 2; i >= 0; --i) 
    {
        dp[i][n - 1] = dp[i + 1][n - 1] + board[i][n - 1];
        path[i][n - 1] = 'U';
    }

    for (int j = n - 2; j >= 0; --j) 
    {
        dp[n - 1][j] = dp[n - 1][j + 1] + board[n - 1][j];
        path[n - 1][j] = 'L';
    }

    for (int i = n - 2; i >= 0; --i) 
    {
        for (int j = n - 2; j >= 0; --j) 
        {
            if (dp[i + 1][j] > dp[i][j + 1]) 
            {
                dp[i][j] = dp[i + 1][j] + board[i][j];
                path[i][j] = 'U';
            }
            else 
            {
                dp[i][j] = dp[i][j + 1] + board[i][j];
                path[i][j] = 'L';
            }
        }
    }
}

/**
 * Восстанавливает путь короля по матрице направлений
 * @param path Матрица направлений (U - вверх, L - влево)
 * @return Строка с описанием пути (например, "U L L U")
 */

 //Нарушение именования функции и параметров
//void p(vector<vector<char>>& put, string& put1)
string ReconstructPath(vector<vector<char>>& path) {
    // FIXME: Было: глобальная переменная n. Исправлено: получаем размер из матрицы path
    int n = path.size();
    // FIXME: Было: put1 как параметр. Исправлено: локальная переменная result
    std::string result;

    // FIXME: Было: i и j объявлены отдельно. Исправлено: компактное объявление
    int i = 0, j = 0;

    while (i < n - 1 || j < n - 1) { 
        if (path[i][j] == 'U') {
            // FIXME: Было: put1 = put1 + "U ". Исправлено на += для эффективности
            result += "U ";
            i++;
        }
        else {
            result += "L ";
            j++;
        }
    }

    reverse(result.begin(), result.end());
    return result;
}

int main() {
    // FIXME: Локализация не нужна для файлового ввода/вывода
    setlocale(LC_ALL, "Russian");

    ifstream input("a.txt");
    ofstream output("b.txt");

    if (!input.is_open() || !output.is_open()) {
        cerr << "Ошибка открытия файлов!" << endl;
        return 1;
    }

    int n;
    input >> n;

    // FIXME: Неинформативные имена переменных
    //vector<vector<int>> pole1(n, vector<int>(n));
    vector<vector<int>> board(n, vector<int>(n));
    //vector<vector<int>> pole2(n, vector<int>(n));
    vector<vector<int>> dp(n, vector<int>(n));
    //vector<vector<char>> put(n, vector<char>(n));
    vector<vector<char>> path(n, vector<char>(n));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            input >> board[i][j];
        }
    }

    SolveKingProblem(board, dp, path);
    string path_str = ReconstructPath(path);

    output << dp[0][0] << "\n";
    output << path_str;

    input.close();
    output.close();

    cout << "Результат записан в файл b.txt" << endl;
    return 0;
}
